<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Hello</title>
</head>
<style>
  body,
  html {
    height: 100%;
    margin: 0;
  }

  .responsive {
    width: 100%;
    height: auto;
  }

  .sidenav {
    height: 100%;
    width: 0;
    position: fixed;
    z-index: 1;
    top: 0;
    left: 0;
    background-color: #111;
    overflow-x: hidden;
    transition: 0.2s;
    padding-top: 60px;
  }

  .sidenav a {
    padding: 8px 8px 8px 32px;
    text-decoration: none;
    font-size: 25px;
    color: #818181;
    display: block;
    transition: 0.2s;
  }

  .sidenav a:hover {
    color: #f1f1f1;
  }

  .sidenav .closebtn {
    position: absolute;
    top: 0;
    right: 25px;
    font-size: 36px;
    margin-left: 50px;
  }

  #main {
    transition: margin-left .5s;
    padding: 16px;
  }

  @media screen and (max-height: 450px) {
    .sidenav {
      padding-top: 15px;
    }

    .sidenav a {
      font-size: 18px;
    }
  }
</style>

<div id="mySidenav" class="sidenav">
  <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>

</div>


<div><span style="font-size:30px;cursor:pointer" onclick="openNav()">&#9776; </span>
  <p id="status">Loading...</p>
</div>
<div id="main">
  <canvas id="canvasOutputTest" width="50" height="50" hidden="True"></canvas>
  <canvas id="canvasCroppedTm" width="256" height="256" hidden="True"></canvas>
  <canvas id="canvasFinalOutput" width="2048" height="2048" display="block"></canvas>
</div>
<div>
  <canvas id="canvasOutput" width="1920" height="1080" hidden="true"></canvas>
</div>
<footer hidden="true">
  <canvas id="canvasX" width="40" height="40" hidden="true"></canvas>
  <img id="fullMap" src="3.png" alt="the fullmap" naturalHeight='2048' naturalWidth="2048" hidden="true" />
  <img id="xxx" src="x.png" alt="the x" hidden="true" />
</footer>
<script type="text/javascript">

  const menu = document.getElementById("mySidenav")
  function openNav() {
    document.getElementById("mySidenav").style.width = "250px";
    document.getElementById("main").style.marginLeft = "250px";
  }

  function closeNav() {
    document.getElementById("mySidenav").style.width = "0";
    document.getElementById("main").style.marginLeft = "0";
  }

  function addImgToMenu() {
    let menuImg = document.createElement("img"); // Use DOM HTMLImageElement
    menuImg.addEventListener("click", clickedMenuImage)
    menuImg.src = canvasCroppedTm.toDataURL();
    //console.log('menu.childElementCount',menu.childElementCount);
    //menuImg.alt = `${menu.childElementCount + 1}`;
    menuImg.id = `${menu.childElementCount}`;
    menuImg.naturalHeight = 250;
    menuImg.naturalWidth = 250;
    menu.appendChild(menuImg);
  }

  function clickedMenuImage(e) {
    var c = document.getElementById("canvasFinalOutput");
    var ctx = c.getContext("2d");
    ctx.beginPath();
    ctx.lineWidth = "5";
    ctx.strokeStyle = "blue";
    ctx.rect(e.target.getAttribute("mxx"), e.target.getAttribute("mY"), 35, 35);
    ctx.stroke();
    //data-m-x="1795" data-m-y="197" data-p-x="1835.3" data-p-y="237.3">
  }

  document.addEventListener("paste", pasteImage);
  //window.addEventListener("resize", reportWindowSize);


  const canvasOutput = document.querySelector("#canvasOutput");
  const canvasCroppedTm = document.querySelector("#canvasCroppedTm");
  const canvasX = document.querySelector("#canvasX");
  const canvasFinalOutput = document.querySelector("#canvasFinalOutput");
  //querySelector is faster? //document.getElementsByClassName("canvasOutput");

  //const offscreen = new OffscreenCanvas(4096, 4096);
  //const oSContext = offscreen.getContext("2d");
  //oSContext.drawImage(fullMap4, 0, 0);
  //const offscreenInputCan = new OffscreenCanvas(4096, 4096);
  //const oSContextInputCan = offscreenInputCan.getContext("2d");

  const ctxF = canvasFinalOutput.getContext('2d', { willReadFrequently: true });
  //ctxF.putImageData('fullMap', 0, 0);

  const cTX = canvasOutput.getContext('2d', { willReadFrequently: true });
  const xContext = canvasX.getContext('2d', { willReadFrequently: true });
  const ctxCroppedMap = canvasCroppedTm.getContext('2d', { willReadFrequently: true });

  //rect(x, y, width, height)

  /*   function reportWindowSize() {
      //canvasFinalOutput.height = window.outerHeight;
      //console.log('window.innerHeight', window.innerHeight, 'canvasFinalOutput.height', canvasFinalOutput.height);
      console.log('window.outerHeight', window.outerHeight, '  window.outerWidth ', window.outerWidth);
      //canvasFinalOutput.width = window.outerWidth;
      //console.log('window.innerWidth', window.innerWidth, 'canvasFinalOutput.width', canvasFinalOutput.width);
    } */

  async function pasteImage() {

    //ctxF.clearRect(0, 0, canvasFinalOutput.width, canvasFinalOutput.height);
    cTX.clearRect(0, 0, canvasOutput.width, canvasOutput.height);
    ctxCroppedMap.clearRect(0, 0, canvasCroppedTm.width, canvasCroppedTm.height);

    xContext.drawImage(xxx, 0, 0);
    ctxF.drawImage(fullMap, 0, 0);

    try {
      const permission = await navigator.permissions.query({
        name: "clipboard-read",
      });
      if (permission.state === "denied") {
        throw new Error("Not allowed to read clipboard.");
      }
      const clipboardContents = await navigator.clipboard.read();
      for (const item of clipboardContents) {
        if (!item.types.includes("image/png")) {
          throw new Error("Clipboard contains non-image data.");
        }
        let blob = await item.getType("image/png")
        await handleImg(blob);
      }
    } catch (error) {
      console.log(error);
      console.error(error.message);
    }
  }

  async function handleImg(blob) {
    let imgPaste = await createImageBitmap(blob);
    cTX.drawImage(imgPaste, 0, 0);

    let src = cv.imread('canvasOutput', cv.IMREAD_GRAYSCALE);
    let templ = cv.imread('canvasX', cv.IMREAD_GRAYSCALE);
    let dst = new cv.Mat();
    let mask = new cv.Mat();
    cv.matchTemplate(src, templ, dst, cv.TM_CCOEFF_NORMED, mask);
    let result = cv.minMaxLoc(dst, mask);
    let maxPoint = result.maxLoc;

    /*     console.log('templ.cols', templ.cols, ' templ.rows ', templ.rows);
        let point = new cv.Point(maxPoint.x + templ.cols, maxPoint.y + templ.rows);
        console.log("input", maxPoint.x, maxPoint.y, point.x, point.y); */

    cv.imshow('canvasOutput', src);

    /*     cTX.rect(maxPoint.x-98, maxPoint.y-98,247,247);
        cTX.lineWidth = "1";
        cTX.strokeStyle = "blue";
        cTX.stroke(); */

    let trimdInput = new cv.Mat();
    //let rect = new cv.Rect(maxPoint.x - 97, maxPoint.y - 97, 245, 245);
    //    let rect = new cv.Rect(maxPoint.x - 95, maxPoint.y - 95, 240, 240);
    //let rect = new cv.Rect(maxPoint.x - 97, maxPoint.y - 99, 245, 245);
    //let rect = new cv.Rect(maxPoint.x - 96, maxPoint.y - 98, 245, 245);
    let rect = new cv.Rect(maxPoint.x - 94, maxPoint.y - 92, 242, 242);
    //console.log("maxpoint-97", maxPoint.x - 97, maxPoint.y - 99);
    //console.log('maxPoint.x - 94',maxPoint.x - 100, '  maxPoint.y - 92' ,  maxPoint.y - 98);
    //console.log('maxPoint.x - 94 +242',maxPoint.x - 100 +248, '  maxPoint.y - 92 + 242' ,  maxPoint.y - 98 + 248);
    trimdInput = src.roi(rect);
    cv.imshow('canvasCroppedTm', trimdInput);
    addImgToMenu();
    src.delete(); trimdInput.delete(); templ.delete(); dst.delete(); mask.delete();


    let srcF = cv.imread('canvasFinalOutput', cv.IMREAD_GRAYSCALE);
    //canvasOutput.setAttribute("hidden", "hidden");
    let templTrimmedMap = cv.imread('canvasCroppedTm', cv.IMREAD_GRAYSCALE);
    let templShrunk = new cv.Mat();
    let dsize = new cv.Size(canvasCroppedTm.height * .125, canvasCroppedTm.width * .125);
    //let dsize = new cv.Size(31,31);
    //console.log(canvasCroppedTm.height / 8, canvasCroppedTm.width / 8);
    cv.resize(templTrimmedMap, templShrunk, dsize, 0, 0, cv.INTER_AREA);
    cv.imshow('canvasOutputTest', templShrunk);
    let dstFinal = new cv.Mat();
    let maskFinal = new cv.Mat();
    cv.matchTemplate(srcF, templShrunk, dstFinal, cv.TM_CCOEFF_NORMED, maskFinal);

    //console.log('maskFinal', maskFinal);
    let resultF = cv.minMaxLoc(dstFinal, maskFinal);
    //console.log(resultF);
    let maxPF = resultF.maxLoc;

    let pointF = new cv.Point(maxPF.x + templShrunk.cols * 1, maxPF.y + templShrunk.rows * 1);
    //console.log('final', maxPF.x, maxPF.y, pointF.x, pointF.y);

    let midY = (pointF.y + maxPF.y) / 2;
    let midX = (pointF.x + maxPF.x) / 2;
    //console.log('x', midX, (pointF.x + maxPF.x) / 2);
    //console.log('midY', midY, (pointF.y + maxPF.y) / 2);
    //console.log('midX', midX, 'midY', midY);
    //console.log('tile 3# ', Math.floor(midX / 256), Math.floor(midY / 256));
    //console.log('tile 4# ',Math.floor((midX*2)/256), Math.floor((midY*2)/256));
    //console.log('tile 5# ',Math.floor((midX*4)/256), Math.floor((midY*4)/256));
    //console.log('tile 6# ',Math.floor((midX*8)/256), Math.floor((midY*8)/256));

    let mapScale = (2048 / 40);
    //console.log('mapScale',mapScale);
    //console.log('scale x', midX/mapScale);
    //console.log('scale y', midY/mapScale);
    let myXTile = Math.floor(midX / mapScale);
    let myYTile = Math.floor(midY / mapScale);
    //console.log('myXTile', myXTile, 'myYTile', myYTile);
    let myXrem;
    let myYrem = (midY) % mapScale;
    //console.log(myXrem*(mapScale/60),myYrem*(mapScale/60));

    let myXCord;
    let myYCord;

    if (myXTile > 20) {
      myXrem = (midX - 5.94) % mapScale;
      myXCord = (myXTile - 20) + "'" + (myXrem * (mapScale / 60)).toFixed(1) + '"E';
      console.log("EAST ", myXCord);
    } else {
      myXrem = (midX - 5.94) % mapScale;
      //console.log(myXTile, "'", myXrem*(mapScale/60), '"W'  );
      myXTile = Math.abs(myXTile - 20)
      myXCord = (myXTile) + "'" + (myXrem * (mapScale / 60)).toFixed(2) + '"W';
      console.log("X", myXCord);
    }

    if (myYTile == 0) {
      console.log('South', myYTile);
    } else {
      myYCord = (myYTile) + "'" + ((myYrem) * (mapScale / 60)).toFixed(1) + '"S';
      console.log("South", myYCord);
    }






    let currImg = document.getElementById(`${menu.childElementCount - 1}`);
    currImg.setAttribute('mxx', maxPF.x);
    currImg.setAttribute('mY', maxPF.y);
    currImg.setAttribute('pX', pointF.x);
    currImg.setAttribute('pY', pointF.y);


    let color = new cv.Scalar(255, 0, 0, 255);
    cv.rectangle(srcF, maxPF, pointF, color, 4, cv.LINE_8, 0);
    cv.imshow('canvasFinalOutput', srcF);

    dstFinal.delete(); maskFinal.delete(); srcF.delete(); templShrunk.delete(); templTrimmedMap.delete();

/* 
    for (let x = 0; x < canvasFinalOutput.width; x += 51.2) {
      ctxF.moveTo(x, 0);
      ctxF.lineTo(x, canvasFinalOutput.height);
    }
    for (let y = 0; y < canvasFinalOutput.height; y += 51.2) {
      ctxF.moveTo(0, y);
      ctxF.lineTo(canvasFinalOutput.width, y);
    }
    ctxF.strokeStyle = "#ddd";
    ctxF.stroke(); */
  }

  const Module = {
    onRuntimeInitialized() {
      document.getElementById('status').innerHTML = '';
    }
  };

</script>
<script async src="opencv.js" type="text/javascript"></script>
</body>

</html>