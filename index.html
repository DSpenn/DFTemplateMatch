<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Hello</title>
</head>
<style>
  body,
  html {
    height: 100%;
    margin: 0;
  }

  .responsive {
    width: 100%;
    height: auto;
  }

  .sidenav {
    height: 100%;
    width: 0;
    position: fixed;
    z-index: 1;
    top: 0;
    left: 0;
    background-color: #111;
    overflow-x: hidden;
    transition: 0.5s;
    padding-top: 60px;
  }

  .sidenav a {
    padding: 8px 8px 8px 32px;
    text-decoration: none;
    font-size: 25px;
    color: #818181;
    display: block;
    transition: 0.3s;
  }

  .sidenav a:hover {
    color: #f1f1f1;
  }

  .sidenav .closebtn {
    position: absolute;
    top: 0;
    right: 25px;
    font-size: 36px;
    margin-left: 50px;
  }

  #main {
    transition: margin-left .5s;
    padding: 16px;
  }

  @media screen and (max-height: 450px) {
    .sidenav {
      padding-top: 15px;
    }

    .sidenav a {
      font-size: 18px;
    }
  }
</style>

<div id="mySidenav" class="sidenav">
  <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>

</div>


<div><span style="font-size:30px;cursor:pointer" onclick="openNav()">&#9776; </span>
  <p id="status">OpenCV.js is loading...</p>
</div>
<div id="main">
  <canvas id="canvasOutputTest" width="50" height="50" hidden="true" ></canvas>
  <div> <canvas id="canvasCroppedTm" width="256" height="256" hidden="true" ></canvas> </div>
  <canvas id="canvasFinalOutput" width="2048" height="2048" display="block"></canvas>
</div>
<div>
  <canvas id="canvasOutput" width="1920" height="1080" hidden="true"></canvas>
</div>
<div hidden="true">
  <canvas id="canvasX" width="40" height="40" hidden="true"></canvas>
  <img id="fullMap" src="3.png" alt="the fullmap" naturalHeight='2048' naturalWidth="2048" hidden="true" />
  <img id="xxx" src="x.png" alt="the x" hidden="true" />
  <img id="anotherX" src="x2.png" alt="the x2" hidden="true" />
</div>
<script type="text/javascript">

  const menu = document.getElementById("mySidenav")
  function openNav() {
    document.getElementById("mySidenav").style.width = "250px";
    document.getElementById("main").style.marginLeft = "250px";
  }

  function closeNav() {
    document.getElementById("mySidenav").style.width = "0";
    document.getElementById("main").style.marginLeft = "0";
  }

  function addImgToMenu() {
    let menuImg = document.createElement("img"); // Use DOM HTMLImageElement
    menuImg.addEventListener("click", clickedMenuImage)
    menuImg.src = canvasCroppedTm.toDataURL();
    //console.log('menu.childElementCount',menu.childElementCount);
    //menuImg.alt = `${menu.childElementCount + 1}`;
    menuImg.id = `${menu.childElementCount}`;
    menuImg.naturalHeight = 250;
    menuImg.naturalWidth = 250;
    menu.appendChild(menuImg);
  }

  function clickedMenuImage(e) {
    //console.log(e.target.getAttribute("mxx"));
    //console.log(e.target.getAttribute("mY"));
    var c = document.getElementById("canvasFinalOutput");
    var ctx = c.getContext("2d");
    ctx.beginPath();
    ctx.lineWidth = "10";
    ctx.strokeStyle = "blue";
    ctx.rect(e.target.getAttribute("mxx"), e.target.getAttribute("mY"), 44, 43);
    ctx.stroke();
    //data-m-x="1795" data-m-y="197" data-p-x="1835.3" data-p-y="237.3">

  }

  document.addEventListener("paste", pasteImage);
  //window.addEventListener("resize", reportWindowSize);


  const canvasOutput = document.querySelector("#canvasOutput");
  const canvasCroppedTm = document.querySelector("#canvasCroppedTm");
  const canvasX = document.querySelector("#canvasX");
  const canvasFinalOutput = document.querySelector("#canvasFinalOutput");
  //querySelector is faster? //document.getElementsByClassName("canvasOutput");

  //const offscreen = new OffscreenCanvas(4096, 4096);
  //const oSContext = offscreen.getContext("2d");
  //oSContext.drawImage(fullMap4, 0, 0);
  //const offscreenInputCan = new OffscreenCanvas(4096, 4096);
  //const oSContextInputCan = offscreenInputCan.getContext("2d");

  const ctxF = canvasFinalOutput.getContext('2d', { willReadFrequently: true });
  //ctxF.putImageData('fullMap', 0, 0);

  const cTX = canvasOutput.getContext('2d', { willReadFrequently: true });
  const xContext = canvasX.getContext('2d', { willReadFrequently: true });
  const ctxCroppedMap = canvasCroppedTm.getContext('2d', { willReadFrequently: true });


  /*   function reportWindowSize() {
      //canvasFinalOutput.height = window.outerHeight;
      //console.log('window.innerHeight', window.innerHeight, 'canvasFinalOutput.height', canvasFinalOutput.height);
      console.log('window.outerHeight', window.outerHeight, '  window.outerWidth ', window.outerWidth);
      //canvasFinalOutput.width = window.outerWidth;
      //console.log('window.innerWidth', window.innerWidth, 'canvasFinalOutput.width', canvasFinalOutput.width);
    } */

  async function pasteImage() {

    //ctxF.clearRect(0, 0, canvasFinalOutput.width, canvasFinalOutput.height);
    cTX.clearRect(0, 0, canvasOutput.width, canvasOutput.height);
    ctxCroppedMap.clearRect(0, 0, canvasCroppedTm.width, canvasCroppedTm.height);

    xContext.drawImage(xxx, 0, 0);
    ctxF.drawImage(fullMap, 0, 0);

    try {
      const permission = await navigator.permissions.query({
        name: "clipboard-read",
      });
      if (permission.state === "denied") {
        throw new Error("Not allowed to read clipboard.");
      }
      const clipboardContents = await navigator.clipboard.read();
      for (const item of clipboardContents) {
        if (!item.types.includes("image/png")) {
          throw new Error("Clipboard contains non-image data.");
        }
        let blob = await item.getType("image/png")
        await handleImg(blob);
      }
    } catch (error) {
      console.log(error);
      console.error(error.message);
    }
  }

  async function handleImg(blob) {
    let imgPaste = await createImageBitmap(blob);
    cTX.drawImage(imgPaste, 0, 0);
    //canvasOutput.removeAttribute("hidden");

    let src = cv.imread('canvasOutput', cv.IMREAD_GRAYSCALE);
    let templ = cv.imread('canvasX', cv.IMREAD_GRAYSCALE);
    let dst = new cv.Mat();
    let mask = new cv.Mat();
    cv.matchTemplate(src, templ, dst, cv.TM_CCOEFF_NORMED, mask);
    let result = cv.minMaxLoc(dst, mask);
    let maxPoint = result.maxLoc;
    let point = new cv.Point(maxPoint.x + templ.cols, maxPoint.y + templ.rows);
    //console.log(maxPoint.x, maxPoint.y, point.x, point.y);
    cv.imshow('canvasOutput', src);

    let trimdInput = new cv.Mat();
    //let rect = new cv.Rect(maxPoint.x - 97, maxPoint.y - 97, 245, 245);
    //    let rect = new cv.Rect(maxPoint.x - 95, maxPoint.y - 95, 240, 240);
    let rect = new cv.Rect(maxPoint.x - 98, maxPoint.y - 98, 246, 246);
    trimdInput = src.roi(rect);
    cv.imshow('canvasCroppedTm', trimdInput);
    addImgToMenu();
    src.delete(); trimdInput.delete(); templ.delete(); dst.delete(); mask.delete();


    let srcF = cv.imread('canvasFinalOutput', cv.IMREAD_GRAYSCALE);
    //canvasOutput.setAttribute("hidden", "hidden");
    let templTrimmedMap = cv.imread('canvasCroppedTm', cv.IMREAD_GRAYSCALE);
    let templShrunk = new cv.Mat();
    let dsize = new cv.Size(canvasCroppedTm.height/7.5, canvasCroppedTm.width/7.5);
    //let dsize = new cv.Size(40,40);
    //console.log(canvasCroppedTm.height/7.5, canvasCroppedTm.width/7.5);
    cv.resize(templTrimmedMap, templShrunk, dsize, 0, 0, cv.INTER_AREA);
    //cv.imshow('canvasOutputTest', templShrunk);
    let dstFinal = new cv.Mat();
    let maskFinal = new cv.Mat();
    cv.matchTemplate(srcF, templShrunk, dstFinal, cv.TM_CCOEFF_NORMED, maskFinal);
    //console.log('maskFinal',maskFinal);

    let resultF = cv.minMaxLoc(dstFinal, maskFinal);
    let maxPF = resultF.maxLoc;

    let pointF = new cv.Point(maxPF.x + templShrunk.cols * 1, maxPF.y + templShrunk.rows * 1);
    console.log('final', maxPF.x, maxPF.y, pointF.x, pointF.y);

    let midY = (pointF.y + maxPF.y) / 2;
    let midX = (pointF.x + maxPF.x) / 2;
    console.log('x', midX, (pointF.x + maxPF.x) / 2);
    console.log('midY', midY, (pointF.y + maxPF.y) / 2);
    //console.log('x tile', midX, midX*8);
    //console.log('y tile', midY, midY*8);
    let currImg = document.getElementById(`${menu.childElementCount - 1}`);
    currImg.setAttribute('mxx', maxPF.x);
    currImg.setAttribute('mY', maxPF.y);
    currImg.setAttribute('pX', pointF.x);
    currImg.setAttribute('pY', pointF.y);


    let color = new cv.Scalar(255, 0, 0, 255);
    cv.rectangle(srcF, maxPF, pointF, color, 4, cv.LINE_8, 0);
    cv.imshow('canvasFinalOutput', srcF);

    dstFinal.delete(); maskFinal.delete(); srcF.delete(); templShrunk.delete(); templTrimmedMap.delete();


/*     for (let x = 0; x < canvasFinalOutput.width; x += 51.2) {
      ctxF.moveTo(x, 0);
      ctxF.lineTo(x, canvasFinalOutput.height);
    }
    for (let y = 0; y < canvasFinalOutput.height; y += 51.2) {
      ctxF.moveTo(0, y);
      ctxF.lineTo(canvasFinalOutput.width, y);
    }
    ctxF.strokeStyle = "#ddd";
    ctxF.stroke();
 */
  }

  const Module = {
    onRuntimeInitialized() {
      document.getElementById('status').innerHTML = 'OpenCV.js is ready.';
    }
  };

</script>
<script async src="opencv.js" type="text/javascript"></script>
</body>

</html>